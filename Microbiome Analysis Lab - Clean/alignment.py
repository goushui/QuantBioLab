# -*- coding: utf-8 -*-
"""
Created on Tue Oct 23 20:48:27 2018

@author: jdkan


"""


#=============================================================
# Alignment Parameters
#=============================================================

class ScoreParam:
    #   Taken from code generated by Carl Kingsford at CMU
    #   https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/align.py


    """Stores the parameters for an alignment scoring function"""
    def __init__(self, match, mismatch, gap, gap_start=0):
        self.gap_start = gap_start
        self.gap = gap
        self.match = match
        self.mismatch = mismatch

    def matchchar(self, a,b):
        """Return the score for aligning character a with b"""
        assert len(a) == len(b) == 1
        if a==b:
            return self.match
        else:
            return self.mismatch

    def __str__(self):
        return "match = %d; mismatch = %d; gap_start = %d; gap_extend = %d" % (
                self.match, self.mismatch, self.gap_start, self.gap
        )

def make_matrix(sizex, sizey):
    #   Taken from code generated by Carl Kingsford at CMU
    #   https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/align.py

    """Creates a sizex by sizey matrix filled with zeros."""
    return [[0]*sizey for i in range(sizex)]


def print_matrix(x, y, A):
    #   Taken from code generated by Carl Kingsford at CMU
    #   https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/align.py

    """Print the matrix with the (0,0) entry in the top left
    corner. Will label the rows by the sequence and add in the
    0-row if appropriate."""


    #print(A,x,y)
    

    # decide whether there is a 0th row/column
    if len(x) == len(A):
        print ("%5s" % (" "),end=" ")
    else:
        print ("%5s %5s" % (" ","*"),end=" ")
        y = "*" + y
    
    # print the top row
    for c in x:
        print ("%5s" % (c),end=" "),
    print()
    
    for j in range(len(A[0])):
        print ("%5s" % (y[j]), end=" ")
        for i in range(len(A)):
            print( "%5.0f" % (A[i][j]), end=" "),
        print()



def local_align(x, y, score=ScoreParam(10, -5, -7), print_output = False):
    # Optimized local alignment: minimize attribute lookups, reuse rows, inline match logic
    """
    Do a local alignment between x and y with the given scoring parameters.
    We assume we are MAXIMIZING.
    """

    nx = len(x) + 1
    ny = len(y) + 1

    # create a zero-filled matrix
    A = make_matrix(nx, ny)

    best = 0
    optloc = (0, 0)

    gap = score.gap
    match_val = score.match
    mismatch_val = score.mismatch

    # fill in A in the right order using row reuse to avoid repeated A indexing
    for i in range(1, nx):
        prev_row = A[i-1]
        curr_row = A[i]
        xi = x[i-1]
        # local variables for speed
        for j in range(1, ny):
            # compute candidates
            left = curr_row[j-1] + gap
            up = prev_row[j] + gap
            diag = prev_row[j-1] + (match_val if xi == y[j-1] else mismatch_val)

            # inline max to avoid tuple creation
            v = left
            if up > v:
                v = up
            if diag > v:
                v = diag
            if 0 > v:
                v = 0

            curr_row[j] = v

            # track best
            if v >= best:
                best = v
                optloc = (i, j)

    if print_output:
        print("Scoring:", str(score))
        print("A matrix =")
        print_matrix(x, y, A)
        print("Optimal Score =", best)
        print("Max location in matrix =", optloc)

    return best, optloc, A



#local_align("ACTG", "ACTGACTGACTG", score=ScoreParam(10, -5, -7))